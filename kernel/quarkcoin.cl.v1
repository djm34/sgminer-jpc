/*
 * QuarkCoin kernel implementation.
 *
 * ==========================(LICENSE BEGIN)============================
 *
 * Copyright (c) 2014  phm
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * ===========================(LICENSE END)=============================
 *
 * @author   phm <phm@inbox.com>
 */

#ifndef QUARKCOIN_CL
#define QUARKCOIN_CL

#if __ENDIAN_LITTLE__
#define SPH_LITTLE_ENDIAN 1
#else
#define SPH_BIG_ENDIAN 1
#endif

#define SPH_UPTR sph_u64

typedef unsigned int sph_u32;
typedef int sph_s32;
#ifndef __OPENCL_VERSION__
typedef unsigned long long sph_u64;
typedef long long sph_s64;
#else
typedef unsigned long sph_u64;
typedef long sph_s64;
#endif

#define SPH_64 1
#define SPH_64_TRUE 1

#define SPH_C32(x)    ((sph_u32)(x ## U))
#define SPH_T32(x)    ((x) & SPH_C32(0xFFFFFFFF))
#define SPH_ROTL32(x, n)   SPH_T32(((x) << (n)) | ((x) >> (32 - (n))))
#define SPH_ROTR32(x, n)   SPH_ROTL32(x, (32 - (n)))

#define SPH_C64(x)    ((sph_u64)(x ## UL))
#define SPH_T64(x)    ((x) & SPH_C64(0xFFFFFFFFFFFFFFFF))
#define SPH_ROTL64(x, n)   SPH_T64(((x) << (n)) | ((x) >> (64 - (n))))
#define SPH_ROTR64(x, n)   SPH_ROTL64(x, (64 - (n)))

#define SPH_ECHO_64 1
#define SPH_KECCAK_64 1
#define SPH_JH_64 1
#define SPH_SIMD_NOCOPY 0
#define SPH_KECCAK_NOCOPY 0
#define SPH_COMPACT_BLAKE_64 0
#define SPH_LUFFA_PARALLEL 0
#define SPH_SMALL_FOOTPRINT_GROESTL 0
#define SPH_GROESTL_BIG_ENDIAN 0

#define SPH_CUBEHASH_UNROLL 0
#define SPH_KECCAK_UNROLL   0

#include "blake.cl"
#include "bmw.cl"
#include "groestl.cl"
#include "jh.cl"
#include "keccak.cl"
#include "skein.cl"

#define SWAP4(x) as_uint(as_uchar4(x).wzyx)
#define SWAP8(x) as_ulong(as_uchar8(x).s76543210)

#if SPH_BIG_ENDIAN
    #define DEC64E(x) (x)
    #define DEC64BE(x) (*(const __global sph_u64 *) (x));
#else
    #define DEC64E(x) SWAP8(x)
    #define DEC64BE(x) SWAP8(*(const __global sph_u64 *) (x));
#endif


void BLAKE512_80(ulong X[16])	{
    sph_u64 H0 = SPH_C64(0x6A09E667F3BCC908), H1 = SPH_C64(0xBB67AE8584CAA73B);
    sph_u64 H2 = SPH_C64(0x3C6EF372FE94F82B), H3 = SPH_C64(0xA54FF53A5F1D36F1);
    sph_u64 H4 = SPH_C64(0x510E527FADE682D1), H5 = SPH_C64(0x9B05688C2B3E6C1F);
    sph_u64 H6 = SPH_C64(0x1F83D9ABFB41BD6B), H7 = SPH_C64(0x5BE0CD19137E2179);
    sph_u64 S0 = 0, S1 = 0, S2 = 0, S3 = 0;
    sph_u64 T0 = SPH_C64(0xFFFFFFFFFFFFFC00) + (80 << 3), T1 = 0xFFFFFFFFFFFFFFFF;;
    if ((T0 = SPH_T64(T0 + 1024)) < 1024) {
        T1 = SPH_T64(T1 + 1);
    }
    sph_u64 M0, M1, M2, M3, M4, M5, M6, M7;
    sph_u64 M8, M9, MA, MB, MC, MD, ME, MF;
    sph_u64 V0, V1, V2, V3, V4, V5, V6, V7;
    sph_u64 V8, V9, VA, VB, VC, VD, VE, VF;
    M0 = X[0];
    M1 = X[1];
    M2 = X[2];
    M3 = X[3];
    M4 = X[4];
    M5 = X[5];
    M6 = X[6];
    M7 = X[7];
    M8 = X[8];
    M9 = X[9];
    MA = 0x8000000000000000;
    MB = 0;
    MC = 0;
    MD = 1;
    ME = 0;
    MF = 0x280;
    COMPRESS64;
    X[0] = H0;
    X[1] = H1;
    X[2] = H2;
    X[3] = H3;
    X[4] = H4;
    X[5] = H5;
    X[6] = H6;
    X[7] = H7;
}    

void BLAKE512_64(ulong X[16])	{
		 sph_u64 H0 = SPH_C64(0x6A09E667F3BCC908), H1 = SPH_C64(0xBB67AE8584CAA73B);
		 sph_u64 H2 = SPH_C64(0x3C6EF372FE94F82B), H3 = SPH_C64(0xA54FF53A5F1D36F1);
		 sph_u64 H4 = SPH_C64(0x510E527FADE682D1), H5 = SPH_C64(0x9B05688C2B3E6C1F);
		 sph_u64 H6 = SPH_C64(0x1F83D9ABFB41BD6B), H7 = SPH_C64(0x5BE0CD19137E2179);
		 sph_u64 S0 = 0, S1 = 0, S2 = 0, S3 = 0;
		 sph_u64 T0 = SPH_C64(0xFFFFFFFFFFFFFC00) + (64 << 3), T1 = 0xFFFFFFFFFFFFFFFF;
		 if ((T0 = SPH_T64(T0 + 1024)) < 1024)	{
				T1 = SPH_T64(T1 + 1);
		 }
		 sph_u64 M0, M1, M2, M3, M4, M5, M6, M7;
		 sph_u64 M8, M9, MA, MB, MC, MD, ME, MF;
		 sph_u64 V0, V1, V2, V3, V4, V5, V6, V7;
		 sph_u64 V8, V9, VA, VB, VC, VD, VE, VF;
		 M0 = X[0];
		 M1 = X[1];
		 M2 = X[2];
		 M3 = X[3];
		 M4 = X[4];
		 M5 = X[5];
		 M6 = X[6];
		 M7 = X[7];
		 M8 = 0x8000000000000000;
		 M9 = 0;
		 MA = 0;
		 MB = 0;
		 MC = 0;
		 MD = 1;
		 ME = 0;
		 MF = 0x200;
		 COMPRESS64;
		 X[0] = H0;
		 X[1] = H1;
		 X[2] = H2;
		 X[3] = H3;
		 X[4] = H4;
		 X[5] = H5;
		 X[6] = H6;
		 X[7] = H7;
}


void BMW512(ulong X[16]) {
    sph_u64 BMW_h1[16], BMW_h2[16];
    sph_u64 mv[16];
    sph_u64 BMW_H[16];
    for(unsigned u = 0; u < 16; u++) BMW_H[u] = BMW_IV512[u];
    mv[ 0] = SWAP8(X[0]);
    mv[ 1] = SWAP8(X[1]);
    mv[ 2] = SWAP8(X[2]);
    mv[ 3] = SWAP8(X[3]);
    mv[ 4] = SWAP8(X[4]);
    mv[ 5] = SWAP8(X[5]);
    mv[ 6] = SWAP8(X[6]);
    mv[ 7] = SWAP8(X[7]);
    mv[ 8] = 0x80;
    mv[ 9] = 0;
    mv[10] = 0;
    mv[11] = 0;
    mv[12] = 0;
    mv[13] = 0;
    mv[14] = 0;
    mv[15] = 0x200;
		
#define M(x)    (mv[x])
#define H(x)    (BMW_H[x])
#define dH(x)   (BMW_h2[x])
    FOLDb;
#undef M
#undef H
#undef dH

#define M(x)    (BMW_h2[x])
#define H(x)    (final_b[x])
#define dH(x)   (BMW_h1[x])
    FOLDb;
#undef M
#undef H
#undef dH

    X[0] = SWAP8(BMW_h1[8]);
    X[1] = SWAP8(BMW_h1[9]);
    X[2] = SWAP8(BMW_h1[10]);
    X[3] = SWAP8(BMW_h1[11]);
    X[4] = SWAP8(BMW_h1[12]);
    X[5] = SWAP8(BMW_h1[13]);
    X[6] = SWAP8(BMW_h1[14]);
    X[7] = SWAP8(BMW_h1[15]);
}


void GROESTL512(ulong X[16]) {
     sph_u64 g[16], m[16], xH[16];
     sph_u64 H[16];
     for (unsigned int u = 0; u < 15; u ++) H[u] = 0;
     #if USE_LE
        H[15] = ((sph_u64)(512 & 0xFF) << 56) | ((sph_u64)(512 & 0xFF00) << 40);
     #else
        H[15] = (sph_u64)512;
     #endif
		 for (uint u = 0; u <  8; u++) m[u] = DEC64E(X[u]);
		 for (uint u = 0; u < 16; u++) g[u] = m[u] ^ H[u];
		 m[ 8] = 0x80; g[8]  = m[ 8] ^ H[ 8];
		 m[ 9] = 0;    g[9]  = m[ 9] ^ H[ 9];
		 m[10] = 0;    g[10] = m[10] ^ H[10];
		 m[11] = 0;    g[11] = m[11] ^ H[11];
		 m[12] = 0;    g[12] = m[12] ^ H[12];
		 m[13] = 0;    g[13] = m[13] ^ H[13];
		 m[14] = 0;    g[14] = m[14] ^ H[14];
		 m[15] = 0x100000000000000; g[15] = m[15] ^ H[15];
		 PERM_BIG_P(g);
		 PERM_BIG_Q(m);
		 for (unsigned int u = 0; u < 16; u ++) H[u] ^= g[u] ^ m[u];
		 for (unsigned int u = 0; u < 16; u ++) xH[u]  = H[u];
		 PERM_BIG_P(xH); 
		 for (unsigned int u = 0; u < 16; u ++) H[u] ^= xH[u];
		 for (unsigned int u = 0; u <  8; u ++) X[u]  = DEC64E(H[u + 8]);
}


void SKEIN512(ulong X[16]) {
     sph_u64 h0 = SPH_C64(0x4903ADFF749C51CE), h1 = SPH_C64(0x0D95DE399746DF03);
	   sph_u64 h2 = SPH_C64(0x8FD1934127C79BCE), h3 = SPH_C64(0x9A255629FF352CB1);
	   sph_u64 h4 = SPH_C64(0x5DB62599DF6CA7B0), h5 = SPH_C64(0xEABE394CA9D5C3F4);
	   sph_u64 h6 = SPH_C64(0x991112C71A75B523), h7 = SPH_C64(0xAE18A40B660FCC33);
     sph_u64 m0, m1, m2, m3, m4, m5, m6, m7;
     sph_u64 bcount = 0;
     m0 = SWAP8(X[0]);
     m1 = SWAP8(X[1]);
     m2 = SWAP8(X[2]);
     m3 = SWAP8(X[3]);
     m4 = SWAP8(X[4]);
     m5 = SWAP8(X[5]);
     m6 = SWAP8(X[6]);
     m7 = SWAP8(X[7]);
     UBI_BIG(480, 64);
     bcount = 0;
     m0 = m1 = m2 = m3 = m4 = m5 = m6 = m7 = 0;
     UBI_BIG(510, 8);
     X[0] = SWAP8(h0);
     X[1] = SWAP8(h1);
     X[2] = SWAP8(h2);
     X[3] = SWAP8(h3);
     X[4] = SWAP8(h4);
     X[5] = SWAP8(h5);
     X[6] = SWAP8(h6);
     X[7] = SWAP8(h7);
}


void JH512(ulong X[16]) {
     sph_u64 h0h = C64e(0x6fd14b963e00aa17), h0l = C64e(0x636a2e057a15d543);
	   sph_u64 h1h = C64e(0x8a225e8d0c97ef0b), h1l = C64e(0xe9341259f2b3c361);
     sph_u64 h2h = C64e(0x891da0c1536f801e), h2l = C64e(0x2aa9056bea2b6d80);
     sph_u64 h3h = C64e(0x588eccdb2075baa6), h3l = C64e(0xa90f3a76baf83bf7);
     sph_u64 h4h = C64e(0x0169e60541e34a69), h4l = C64e(0x46b58a8e2e6fe65a);
	   sph_u64 h5h = C64e(0x1047a7d0c1843c24), h5l = C64e(0x3b6e71b12d5ac199);
	   sph_u64 h6h = C64e(0xcf57f6ec9db1f856), h6l = C64e(0xa706887c5716b156);
     sph_u64 h7h = C64e(0xe3c2fcdfe68517fb), h7l = C64e(0x545a4678cc8cdd4b);
     sph_u64 tmp;
     for(int i = 0; i < 2; i++) {
        if (i == 0) {
            h0h ^= DEC64E(X[0]);
            h0l ^= DEC64E(X[1]);
            h1h ^= DEC64E(X[2]);
            h1l ^= DEC64E(X[3]);
            h2h ^= DEC64E(X[4]);
            h2l ^= DEC64E(X[5]);
            h3h ^= DEC64E(X[6]);
            h3l ^= DEC64E(X[7]);
        } else if(i == 1) {
            h4h ^= DEC64E(X[0]);
            h4l ^= DEC64E(X[1]);
            h5h ^= DEC64E(X[2]);
            h5l ^= DEC64E(X[3]);
            h6h ^= DEC64E(X[4]);
            h6l ^= DEC64E(X[5]);
            h7h ^= DEC64E(X[6]);
            h7l ^= DEC64E(X[7]);
            h0h ^= 0x80;
            h3l ^= 0x2000000000000;
        }
        E8;
    }
    h4h ^= 0x80;
    h7l ^= 0x2000000000000;
    X[0] = DEC64E(h4h);
    X[1] = DEC64E(h4l);
    X[2] = DEC64E(h5h);
    X[3] = DEC64E(h5l);
    X[4] = DEC64E(h6h);
    X[5] = DEC64E(h6l);
    X[6] = DEC64E(h7h);
    X[7] = DEC64E(h7l);
}
	

void KECCAK512(ulong X[16]) {
     sph_u64 a00 = 0, a01 = 0, a02 = 0, a03 = 0, a04 = 0;
     sph_u64 a10 = 0, a11 = 0, a12 = 0, a13 = 0, a14 = 0; 
     sph_u64 a20 = 0, a21 = 0, a22 = 0, a23 = 0, a24 = 0;
     sph_u64 a30 = 0, a31 = 0, a32 = 0, a33 = 0, a34 = 0;
     sph_u64 a40 = 0, a41 = 0, a42 = 0, a43 = 0, a44 = 0;
     a10 = SPH_C64(0xFFFFFFFFFFFFFFFF);
     a20 = SPH_C64(0xFFFFFFFFFFFFFFFF);
     a31 = SPH_C64(0xFFFFFFFFFFFFFFFF);
     a22 = SPH_C64(0xFFFFFFFFFFFFFFFF);
     a23 = SPH_C64(0xFFFFFFFFFFFFFFFF);
     a04 = SPH_C64(0xFFFFFFFFFFFFFFFF);
     a00 ^= SWAP8(X[0]);
     a10 ^= SWAP8(X[1]);
     a20 ^= SWAP8(X[2]);
     a30 ^= SWAP8(X[3]);
     a40 ^= SWAP8(X[4]);
     a01 ^= SWAP8(X[5]);
     a11 ^= SWAP8(X[6]);
     a21 ^= SWAP8(X[7]);
     a31 ^= 0x8000000000000001;
     KECCAK_F_1600;
     a10 = ~a10;
     a20 = ~a20;
     X[0] = SWAP8(a00);
     X[1] = SWAP8(a10);
     X[2] = SWAP8(a20);
     X[3] = SWAP8(a30);
     X[4] = SWAP8(a40);
     X[5] = SWAP8(a01);
     X[6] = SWAP8(a11);
     X[7] = SWAP8(a21);
}
	

#define WORKSIZE 64

__attribute__((reqd_work_group_size(WORKSIZE, 1, 1)))

__kernel void search(__global unsigned char* block, volatile __global uint* output, const ulong target) {
	
    uint gid = SWAP4(get_global_id(0));	
	  ulong HASH[16];
	
		HASH[0]  = DEC64BE(block +  0);
    HASH[1]  = DEC64BE(block +  8);
    HASH[2]  = DEC64BE(block + 16);
    HASH[3]  = DEC64BE(block + 24);
    HASH[4]  = DEC64BE(block + 32);
    HASH[5]  = DEC64BE(block + 40);
    HASH[6]  = DEC64BE(block + 48);
    HASH[7]  = DEC64BE(block + 56);
    HASH[8]  = DEC64BE(block + 64);
    HASH[9]  = DEC64BE(block + 72);
    HASH[9] &= 0xFFFFFFFF00000000;
    HASH[9] ^= gid;
		
	  BLAKE512_80(HASH);
		BMW512(HASH);
    if (HASH[0x00] & 0x0800000000000000UL) { 
		    GROESTL512(HASH);
    } 
		else {
		    SKEIN512(HASH);
    }
		GROESTL512(HASH);
		JH512(HASH);
    if (HASH[0x00] & 0x0800000000000000UL) {
	     BLAKE512_64(HASH);
    } 
		else {
		    BMW512(HASH);
		}
	  KECCAK512(HASH);
		SKEIN512(HASH);
    if (HASH[0x00] & 0x0800000000000000UL) {
			 KECCAK512(HASH);
    } else {
			 JH512(HASH);
    }

    if (SWAP8(HASH[3]) <= target) {
        output[output[0xFF]++] = gid;
		}
}

#endif // QUARKCOIN_CL
