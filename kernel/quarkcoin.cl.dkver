/*
 * QuarkCoin kernel implementation.
 *
 * ==========================(LICENSE BEGIN)============================
 *
 * Copyright (c) 2014  phm
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * ===========================(LICENSE END)=============================
 *
 * @author   phm <phm@inbox.com>
 */

#ifndef QUARKCOIN_CL
#define QUARKCOIN_CL

#if __ENDIAN_LITTLE__
    #define SPH_LITTLE_ENDIAN 1
#else
    #define SPH_BIG_ENDIAN 1
#endif

#define SPH_UPTRs                         sph_u64

typedef uint                              sph_u32;
typedef int                               sph_s32;
typedef ulong                             sph_u64;
typedef long                              sph_s64;

#define SPH_64                            1
#define SPH_64_TRUE                       1

#define SPH_C32(x)                        ((sph_u32)(x ## U))
#define SPH_T32(x)                        ((x) & SPH_C32(0xFFFFFFFF))
// #define SPH_ROTL32(x, n)                  SPH_T32(((x) << (n)) | ((x) >> (32 - (n))))
#define SPH_ROTL32(x, n)                  rotate(x, n)
#define SPH_ROTR32(x, n)                  SPH_ROTL32(x, (32 - (n)))

#define SPH_C64(x)                        ((sph_u64)(x ## UL))
#define SPH_T64(x)                        ((x) & SPH_C64(0xFFFFFFFFFFFFFFFF))
//#define SPH_ROTL64(x, n)                  SPH_T64(((x) << (n)) | ((x) >> (64 - (n))))
#define SPH_ROTL64(x, n)                  rotate(x, (ulong)(n))
#define SPH_ROTR64(x, n)                  SPH_ROTL64(x, (64 - (n)))

#define SWAP4(x)                          as_uint(as_uchar4(x).wzyx)
#define SWAP8(x)                          as_ulong(as_uchar8(x).s76543210)

#if SPH_BIG_ENDIAN
    #define DEC64E(x)                     (x)
    #define DEC64BE(x)                    (*(const __global sph_u64 *) (x));
#else
    #define DEC64E(x)                     SWAP8(x)
    #define DEC64BE(x)                    SWAP8(*(const __global sph_u64 *) (x));
#endif


//#define SPH_ECHO_64                       1
#define SPH_KECCAK_64                     1
#define SPH_JH_64                         1
#define SPH_KECCAK_NOCOPY                 0
#define SPH_COMPACT_BLAKE_64              0
#define SPH_SMALL_FOOTPRINT_GROESTL       0
#define SPH_GROESTL_BIG_ENDIAN            0
#define SPH_KECCAK_UNROLL                 0

#include "blake.cl"
#include "bmw.cl"
#include "groestl.cl"
#include "jh.cl"
#include "keccak.cl"
#include "skein.cl"

__attribute__((reqd_work_group_size(WORKSIZE, 1, 1)))
__kernel void search(__global unsigned char* block, volatile __global uint* output, const ulong target) {
	
    uint  gid = SWAP4(get_global_id(0));	
	
	  ulong X[8], X8, X9;
	
		X[0]  = DEC64BE(block +  0);
    X[1]  = DEC64BE(block +  8);
    X[2]  = DEC64BE(block + 16);
    X[3]  = DEC64BE(block + 24);
    X[4]  = DEC64BE(block + 32);
    X[5]  = DEC64BE(block + 40);
    X[6]  = DEC64BE(block + 48);
    X[7]  = DEC64BE(block + 56);
    X8    = DEC64BE(block + 64);
    X9    = DEC64BE(block + 72);
    X9   &= 0xFFFFFFFF00000000;
    X9   ^= gid;
	
	  BLAKE64_80(X, X8, X9);
		BMW64(X);
    if (as_uchar8(X[0x00]).s7 & 0x08) {
		   GROESTL64(X);
    } 
		else {
		   SKEIN64(X);
    }
		GROESTL64(X);
		JH64(X);
    if (as_uchar8(X[0x00]).s7 & 0x08) {
	     BLAKE64(X);
    } 
		else {
		   BMW64(X);
		}
	  KECCAK64(X);
		SKEIN64(X);
    if (as_uchar8(X[0x00]).s7 & 0x08) {
			 KECCAK64(X);
    } else {
			 JH64(X);
    }
		
    if (SWAP8(X[3]) <= target) {
       output[output[0xFF]++] = gid;
		}
}

#endif // QUARKCOIN_CL
